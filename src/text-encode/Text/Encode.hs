{- | This module provides classes and newtypes for deriving uniform textual
encodings.

An instance @'TextEncode' A@ defines a uniform textual representation for data
of type @A@. Writing instances is usually straightforward, or they may be
derived using 'DeriveTextEncode'. Use 'ViaTextEncode' to derive instances of
other classes based on a type's 'TextEncode' instance.

For example,
@
    import Text.Encode

    import Text.Encode.Aeson ()
    import Text.Encode.Cassava ()
    import Text.Encode.Persistent ()

    data MyType = MyTypePrimitives | MyTypeBar | MyTypePrimitivesBar
        deriving stock (Read, Show)
        deriving 'TextEncode'
            via 'ReadShowEncoding' ('Cased' 'Pascal' 'QuietSnake' ('DropPrefix' "MyType" ())) MyType
        deriving
            ( Aeson.FromJSON, Aeson.ToJSON
            , Cassava.FromField, Cassava.ToField
            , Persistent.PersistField
            )
            via 'ViaTextEncode' MyType
@

This will derive a 'TextEncode' instance for @MyType@ based on the stock 'Read'
and 'Show' instances, modified by the 'Cased' and 'DropPrefix' options. Uniform,
mutually-consistent instances for Aeson, Cassava, and Persistent classes are
then derived from the derived 'TextEncode' instance.

__N.B.__ Using 'Cased' or 'DropPrefix' will cause create intermediate 'String'
values when serializing and deserializing, which may impact performance. In
practice, these 'String' values are short, and they're used over a relatively
high latency network, so the performance impact is usually negligible. In the
rare case that performance is a concern, there are a few options:
1.  Use 'AesonEncoding' to derive 'TextEncode' for a type that efficient
    'FromJSON' and 'ToJSON' instances (such as generated by Template Haskell).
2.  Derive 'TextEncode' using 'BoundedEnumEncoding'. The representation will
    consist of an integer, still encoded as a 'String', but without any
    transformations. Serialization will use 'fromEnum' and 'show'.
    Deserialization will use 'readMaybe' and 'toEnum'.
3.  Write a custom 'TextEncode' instance. Depending on the particulars of the
    functions you are using to send data over the wire, you probably want to
    write your instance in terms of 'encodeLazyByteString' (internally using a
    'Builder') and 'decodeLazyByteString'. With optimizations,
    @'lazyByteString' . 'toLazyByteString'@ on 'Builder' will fuse to 'id' and
    be compiled away.
4.  Consider using a library designed for high-performance binary serialization,
    such as _binary_, for these specific use cases.
-}
module Text.Encode (
    -- * Textual Encodings
    TextEncode (..),

    -- * Deriving 'TextEncode'

    -- ** 'String'-based encodings
    BoundedEnumEncoding (..),
    ReadShowEncoding (..),
    DropPrefix,
    AddPrefix,
    Casing (..),
    CaseConversion (..),
    Cased,

    -- ** Specialized encodings
    ByteStringEncoding (..),
    ByteStringPrimitives (..),
    LazyByteStringEncoding (..),
    LazyByteStringPrimitives (..),
    TextEncoding (..),
    TextPrimitives (..),
    LazyTextEncoding (..),
    LazyTextPrimitives (..),

    -- * Deriving other classes
    ViaTextEncode (..),

    -- * Utilities
    FunctionName,
    Message,
    Input,
    typedError,
    decodeError,
    maybeDecode,
) where

import Text.Encode.Casing

import Control.Monad (guard, (<=<))
import Data.Coerce (coerce)
import Data.Kind (Type)
import Data.Typeable (Proxy (..), Typeable, typeRep)
import GHC.TypeLits (KnownSymbol, Symbol, symbolVal)
import Text.Convert (
    ByteString,
    LazyByteString,
    LazyText,
    Text,
    asByteString,
    asLazyByteString,
    asLazyText,
    asString,
    asText,
 )
import Text.Read (readMaybe)

{- | An instance @'TextEncode' A@ defines a uniform textual representation for
data of type @A@.

Instances are assumed to follow these mutual-coherence properties:
* @decodeString . encodeString === Right@
* @fmap encodeString . decodeString === Right@
* @decodeText . "Data.Text".'pack' . encodeString === Right@
* @fmap encodeString . decodeByteString === Right . "Data.ByteString.Char8".'unpack'@
and permutations thereof.

Mutually-coherent default definitions of the methods are provided, though
users may supply their own implementations for performance reasons. It is the
user's responsibility to ensure that these definitions mutually cohere.

Minimal definitiions consist of 'encodeString' and 'decodeString'. To define
an instance based on a textual type other than 'String', see the specialized
encodings:
* 'ByteStringEncoding',
* 'LazyByteStringEncoding',
* 'TextEncoding',
* 'LazyTextEncoding'.
-}
class TextEncode a where
    {-# MINIMAL encodeString, decodeString #-}
    encodeString :: a -> String
    decodeString :: String -> Either String a

    encodeByteString :: a -> ByteString
    decodeByteString :: ByteString -> Either String a

    encodeLazyByteString :: a -> LazyByteString
    decodeLazyByteString :: LazyByteString -> Either String a

    encodeText :: a -> Text
    decodeText :: Text -> Either String a

    encodeLazyText :: a -> LazyText
    decodeLazyText :: LazyText -> Either String a

    encodeText = asText . encodeString
    decodeText = decodeString . asString

    encodeLazyText = asLazyText . encodeString
    decodeLazyText = decodeString . asString

    encodeByteString = asByteString . encodeString
    decodeByteString = decodeString . asString

    encodeLazyByteString = asLazyByteString . encodeString
    decodeLazyByteString = decodeString . asString

    {-# INLINE encodeByteString #-}
    {-# INLINE decodeByteString #-}
    {-# INLINE encodeLazyByteString #-}
    {-# INLINE decodeLazyByteString #-}
    {-# INLINE encodeText #-}
    {-# INLINE decodeText #-}
    {-# INLINE encodeLazyText #-}
    {-# INLINE decodeLazyText #-}

{- | Derive instances of various classes based on an instance of 'TextEncode'.

@
    data MyType = ...

    instance 'TextEncode' MyType where ...

    deriving via 'ViaTextEncode' MyType instance FromHttpApiData MyType
    deriving via 'ViaTextEncode' MyType instance ToHttpApiData MyType
    deriving via 'ViaTextEncode' MyType instance PersistField MyType
@

See the following modules:
* "Text.Encode.Aeson"
* "Text.Encode.Cassava"
* "Text.Encode.HttpApiData"
* "Text.Encode.Persistent"
* "Text.Encode.PostgresqlSimple"
* "Text.Encode.SqliteSimple"
-}
newtype ViaTextEncode a = ViaTextEncode a
    deriving (TextEncode) via a

instance (TextEncode a) => Show (ViaTextEncode a) where
    show (ViaTextEncode a) = encodeString a

instance (TextEncode a) => Read (ViaTextEncode a) where
    readsPrec _ = either (const []) (pure . (,"") . ViaTextEncode) . decodeString

{- | Derive 'TextEncode' using 'Read' and 'Show'.

@
    data MyType = MyTypeFoo | MyTypeBar | MyTypeFooBar
        deriving stock (Read, Show)
        deriving TextEncode
            via ReadShowEncoding
                    (Cased Pascal QuietSnake (DropPrefix "MyType" ()))
                    MyType
@
-}
newtype ReadShowEncoding opt a = ReadShowEncoding a
    deriving (Read, Show) via a

instance (Read a, Show a, Typeable a) => TextEncode (ReadShowEncoding () a) where
    encodeString = show
    decodeString = coerce $ maybeDecode @a readMaybe

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}

data DropPrefix (pfx :: Symbol) (opt :: Type)

instance (KnownSymbol pfx, TextEncode (ReadShowEncoding opt a)) => TextEncode (ReadShowEncoding (DropPrefix pfx opt) a) where
    encodeString = coerce $ dropPfx @pfx . encodeString @(ReadShowEncoding opt a)
    decodeString = coerce $ decodeString @(ReadShowEncoding opt a) . (symbolVal (Proxy @pfx) <>)

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}

data AddPrefix (pfx :: Symbol) (opt :: Type)

instance (KnownSymbol pfx, TextEncode (ReadShowEncoding opt a)) => TextEncode (ReadShowEncoding (AddPrefix pfx opt) a) where
    encodeString = coerce $ (symbolVal (Proxy @pfx) <>) . encodeString @(ReadShowEncoding opt a)
    decodeString = coerce $ decodeString @(ReadShowEncoding opt a) . dropPfx @pfx

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}

data Cased (decoding :: Casing) (encoding :: Casing) (opt :: Type)

instance (CaseConversion d e, TextEncode (ReadShowEncoding opt a)) => TextEncode (ReadShowEncoding (Cased d e opt) a) where
    encodeString = coerce $ encoding @d @e . encodeString @(ReadShowEncoding opt a)
    decodeString = coerce $ decodeString @(ReadShowEncoding opt a) . decoding @d @e

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}

{- | Derive 'TextEncode' using 'Bounded' and 'Enum'.

@
    data MyType = MyTypeFoo | MyTypeBar | MyTypeFooBar
        deriving stock (Bounded, Enum)
        deriving TextEncode BoundedEnumEncoding
@
-}
newtype BoundedEnumEncoding a = BoundedEnumEncoding a
    deriving (Bounded, Enum) via a

instance (Bounded a, Enum a, Typeable a) => TextEncode (BoundedEnumEncoding a) where
    encodeString = show . fromEnum
    decodeString = coerce $ maybeDecode @a $ toEnumMaybe <=< readMaybe

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}

{- | Define @'ByteStringPrimitives' A@ to derive @'TextEncode' A@ in terms of
'ByteString' primitives. This is often more efficient than using the default
'TextEncode' instance methods, which use 'String' as an intermediate
representation.

@
    newtype MyType = ...

    instance ByteStringPrimitives MyType where ...

    deriving via ByteStringEncoding MyType instance TextEncode MyType
@
-}
newtype ByteStringEncoding a = ByteStringEncoding a
    deriving (ByteStringPrimitives) via a

class ByteStringPrimitives a where
    byteStringEncode :: a -> ByteString
    byteStringDecode :: ByteString -> Either String a

instance (ByteStringPrimitives a) => TextEncode (ByteStringEncoding a) where
    encodeString = coerce $ asString . byteStringEncode @a
    decodeString = coerce $ byteStringDecode @a . asByteString @String

    encodeByteString = coerce $ byteStringEncode @a
    decodeByteString = coerce $ byteStringDecode @a

    encodeLazyByteString = coerce $ asLazyByteString . byteStringEncode @a
    decodeLazyByteString = coerce $ byteStringDecode @a . asByteString @LazyByteString

    encodeText = coerce $ asText . byteStringEncode @a
    decodeText = coerce $ byteStringDecode @a . asByteString @Text

    encodeLazyText = coerce $ asLazyText . byteStringEncode @a
    decodeLazyText = coerce $ byteStringDecode @a . asByteString @LazyText

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}
    {-# INLINE encodeByteString #-}
    {-# INLINE decodeByteString #-}
    {-# INLINE encodeLazyByteString #-}
    {-# INLINE decodeLazyByteString #-}
    {-# INLINE encodeText #-}
    {-# INLINE decodeText #-}
    {-# INLINE encodeLazyText #-}
    {-# INLINE decodeLazyText #-}

{- | Define @'LazyByteStringPrimitives' A@ to derive @'TextEncode' A@ in terms
of 'LazyByteString' primitives. This is often more efficient than using the
default 'TextEncode' instance methods, which use 'String' as an intermediate
representation.

@
    newtype MyType = ...

    instance LazyByteStringPrimitives MyType where ...

    deriving via LazyByteStringEncoding MyType instance TextEncode MyType
@
-}
newtype LazyByteStringEncoding a = LazyByteStringEncoding a

class LazyByteStringPrimitives a where
    lazyByteStringEncode :: a -> LazyByteString
    lazyByteStringDecode :: LazyByteString -> Either String a

instance (LazyByteStringPrimitives a) => TextEncode (LazyByteStringEncoding a) where
    encodeString = coerce $ asString . lazyByteStringEncode @a
    decodeString = coerce $ lazyByteStringDecode @a . asLazyByteString @String

    encodeByteString = coerce $ asByteString . lazyByteStringEncode @a
    decodeByteString = coerce $ lazyByteStringDecode @a . asLazyByteString @ByteString

    encodeLazyByteString = coerce $ lazyByteStringEncode @a
    decodeLazyByteString = coerce $ lazyByteStringDecode @a

    encodeText = coerce $ asText . lazyByteStringEncode @a
    decodeText = coerce $ lazyByteStringDecode @a . asLazyByteString @Text

    encodeLazyText = coerce $ asLazyText . lazyByteStringEncode @a
    decodeLazyText = coerce $ lazyByteStringDecode @a . asLazyByteString @LazyText

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}
    {-# INLINE encodeByteString #-}
    {-# INLINE decodeByteString #-}
    {-# INLINE encodeLazyByteString #-}
    {-# INLINE decodeLazyByteString #-}
    {-# INLINE encodeText #-}
    {-# INLINE decodeText #-}
    {-# INLINE encodeLazyText #-}
    {-# INLINE decodeLazyText #-}

{- | Define @'TextPrimitives' A@ to derive @'TextEncode' A@ in terms of
'Text' primitives. This is often more efficient than using the default
'TextEncode' instance methods, which use 'String' as an intermediate
representation.

@
    newtype MyType = ...

    instance TextPrimitives MyType where ...

    deriving via TextEncoding MyType instance TextEncode MyType
@
-}
newtype TextEncoding a = TextEncoding a
    deriving (TextPrimitives) via a

class TextPrimitives a where
    textEncode :: a -> Text
    textDecode :: Text -> Either String a

instance (TextPrimitives a) => TextEncode (TextEncoding a) where
    encodeString = coerce $ asString . textEncode @a
    decodeString = coerce $ textDecode @a . asText @String

    encodeByteString = coerce $ asByteString . textEncode @a
    decodeByteString = coerce $ textDecode @a . asText @ByteString

    encodeLazyByteString = coerce $ asLazyByteString . textEncode @a
    decodeLazyByteString = coerce $ textDecode @a . asText @LazyByteString

    encodeText = coerce $ textEncode @a
    decodeText = coerce $ textDecode @a

    encodeLazyText = coerce $ asLazyText . textEncode @a
    decodeLazyText = coerce $ textDecode @a . asText @LazyText

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}
    {-# INLINE encodeByteString #-}
    {-# INLINE decodeByteString #-}
    {-# INLINE encodeLazyByteString #-}
    {-# INLINE decodeLazyByteString #-}
    {-# INLINE encodeText #-}
    {-# INLINE decodeText #-}
    {-# INLINE encodeLazyText #-}
    {-# INLINE decodeLazyText #-}

{- | Define @'LazyTextPrimitives' A@ to derive @'TextEncode' A@ in terms of
'LazyText' primitives. This is often more efficient than using the default
'TextEncode' instance methods, which use 'String' as an intermediate
representation.

@
    newtype MyType = ...

    instance LazyTextPrimitives MyType where ...

    deriving via LazyTextEncoding MyType instance TextEncode MyType
@
-}
newtype LazyTextEncoding a = LazyTextEncoding a
    deriving (LazyTextPrimitives) via a

class LazyTextPrimitives a where
    lazyTextEncode :: a -> LazyText
    lazyTextDecode :: LazyText -> Either String a

instance (LazyTextPrimitives a) => TextEncode (LazyTextEncoding a) where
    encodeString = coerce $ asString . lazyTextEncode @a
    decodeString = coerce $ lazyTextDecode @a . asLazyText @String

    encodeByteString = coerce $ asByteString . lazyTextEncode @a
    decodeByteString = coerce $ lazyTextDecode @a . asLazyText @ByteString

    encodeLazyByteString = coerce $ asLazyByteString . lazyTextEncode @a
    decodeLazyByteString = coerce $ lazyTextDecode @a . asLazyText @LazyByteString

    encodeText = coerce $ asText . lazyTextEncode @a
    decodeText = coerce $ lazyTextDecode @a . asLazyText @Text

    encodeLazyText = coerce $ asLazyText . lazyTextEncode @a
    decodeLazyText = coerce $ lazyTextDecode @a . asLazyText @LazyText

    {-# INLINE encodeString #-}
    {-# INLINE decodeString #-}
    {-# INLINE encodeByteString #-}
    {-# INLINE decodeByteString #-}
    {-# INLINE encodeLazyByteString #-}
    {-# INLINE decodeLazyByteString #-}
    {-# INLINE encodeText #-}
    {-# INLINE decodeText #-}
    {-# INLINE encodeLazyText #-}
    {-# INLINE decodeLazyText #-}

type FunctionName = String
type Message = String
type Input a = a

typedError :: forall a b. (Typeable a, Show b) => FunctionName -> Message -> Input b -> String
typedError fn msg input = mconcat [fn, " @", show (typeRep $ Proxy @a), ": ", msg, show input]

decodeError :: forall a b. (Typeable a) => Input String -> Either String b
decodeError input = Left $ typedError @a "decode" "Failed to decode " input

maybeDecode :: forall a. (Typeable a) => (String -> Maybe a) -> Input String -> Either String a
maybeDecode f raw = maybe (decodeError @a raw) Right $ f raw

toEnumMaybe :: forall a. (Bounded a, Enum a) => Int -> Maybe a
toEnumMaybe n = toEnum n <$ guard (fromEnum (minBound @a) <= n && n <= fromEnum (maxBound @a))

dropPfx :: forall pfx. (KnownSymbol pfx) => String -> String
dropPfx = drop $ length $ symbolVal $ Proxy @pfx

{-# INLINE typedError #-}
{-# INLINE decodeError #-}
{-# INLINE maybeDecode #-}
{-# INLINE toEnumMaybe #-}
{-# INLINE dropPfx #-}
